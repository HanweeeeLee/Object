# UML

## 클래스
### 클래스는 "변화의 기본 단위"
### UML 클래스의 표현
 - 가장 윗부분: 클래스 이름
 - 중간 부분: 속성(클래스의 특징)
 - 마지막 부분: 연산(클래스가 수행하는 책임)
 - 경우에 따라 속성 부분과 연산 부분은 생략할 수 있다.
 - UML에서는 접근제어자를 사용해 나타낸다.
 
 | 접근 제어자 | 표시 | 설명 |  
 |:---:|:---:|:---:|
 | public | "+" | 어떤 클래스의 객체에서든 접근 가능 |
 | private | "-" | 이 클래스에서 생성된 객체들만 접근 가능 |
 | protected | "#" | 이 클래스와 동일 패키지에 있거나 상속 관계에 있는 하위 클래스의 객체들만 접근 가능 |
 | package | "~" | 동일 패키지에 있는 클래스의 객체들만 접근 가능 |
 
 ex)
 <img width="228" alt="스크린샷 2021-05-27 오후 8 29 29" src="https://user-images.githubusercontent.com/60125719/119818503-41e52500-bf2a-11eb-8af0-0ff2d8318f3c.png">
 
 ## 관계
 ### UML에서 제공하는 클래스들 사이의 관계
 
 | 관계 | 표시 | 설명 |  
 |:---:|:---:|:---:|
 | 연관 관계  (association) | 실선이나 화살표 | 클래스들이 *개념상 서로 연결*되었음을 나타낸다.  보통은 한 클래스가 다른 클래스에서 제공하는 기능을 사용하는 상황일 때 표시한다. |
 | 일반화 관계  (generalization) | 속이 빈 화살표 | 객체지향 개념에서는 *상속관계*라고 한다.  한 클래스가 다른 클래스를 포함하는 상위 개념일 때 이를 IS-A 관계라고 하며 UML에서는 일반화 관계로 모델링한다. |
 | 집약 관계  (aggregation) | 속이 빈 다이아몬드 | 클래스들 사이의 전체 또는 부분 같은 관계를 나타낸다.  전체 객체의 라이프타임과 부분 객체의 라이프 타임은 *독립적*이다.  즉, 전체 객체가 없어져도 부분 객체는 없어지지 않는다. |
 | 합성 관계  (composition) | 속이 찬 다이아몬드 | 클래스들 사이의 전체 또는 부분 같은 관계를 나타낸다.  전체 객체의 라이프타임과 부분 객체의 라이프타임은 *의존적*이다.  즉, 전체 객체가 없어지면 부분 객체도 없어진다. |
 | 의존 관계  (dependency) | 점선 화살표 | 연관 관계와 같이 한 클래스가 다른 클래스에서 제공하는 기능을 사용할 때를 나타낸다.  차이점은 두 클래스의 관계가 한 메서드를 실행하는 동안과 같은, *매우 짧은 시간만 유지*된다는 점이다. |
 | 실체화 관계  (realization) | 빈 삼각형과 점선 | 책임들의 집합인 *인터페이스*와 이 책임들을 실제로 실현한 *클래스들 사이의 관계*를 나타낸다. |
 
 ### 1. 연관 관계
 #### 한 클래스가 다른 클래스와 연관 관계를 가지면 각 클래스의 객체는 해당 연관 관계에서 어떤 역할을 수행하게 된다.
  - 두 클래스 사이의 연관 관계가 명확한 경우에는 연관 관계 이름을 사용하지 않아도 된다.
  - 역할 이름은 실제 프로그램을 구현할 때 연관된 클래스의 객체들이 서로를 참조할 수 있는 속성의 이름으로 활용할 수 있다.
  - 연관 관계는 방향성을 가질 수 있다. 양방향은 실선으로, 단방향은 화살표로 표시한다.
  
ex) 단방향 연관 관계 (화살표)
  > 한 쪽은 알지만 다른 쪽은 상대방의 존재를 모른다.
  <img width="435" alt="스크린샷 2021-05-27 오후 8 53 55" src="https://user-images.githubusercontent.com/60125719/119821661-c71e0900-bf2d-11eb-8180-b6e2a51aa390.png">

ex) 양방향 연관 관계 (실선) 
> 두 클래스의 객체들이 서로의 존재를 인식한다.
<img width="371" alt="스크린샷 2021-05-27 오후 8 56 50" src="https://user-images.githubusercontent.com/60125719/119821958-17956680-bf2e-11eb-9ed2-6d1ba1125005.png">

### 2. 일반화 관계
#### 한 클래스가 다른 클래스를 포함하는 상위 개념일 때 두 클래스 사이에는 일반화 관계가 존재한다.  
#### 객체지향 개념에서는 일반화 관계를 상속관계(is a kind of 관계) 라고 한다.
<img width="509" alt="스크린샷 2021-05-27 오후 9 00 36" src="https://user-images.githubusercontent.com/60125719/119822441-9ee2da00-bf2e-11eb-8135-f7d6b2960d1b.png">

 - 부모 클래스는 자식 클래스의 공통 속성이나 연산을 제공하는 틀이다.
 - 추상클래스는 다른 일반적인 클래스와는 달리 객체를 생성할 수 없다.
 <img width="330" alt="스크린샷 2021-05-27 오후 9 21 29" src="https://user-images.githubusercontent.com/60125719/119825086-8fb15b80-bf31-11eb-878e-dce5ce5643e9.png">


### 3. 집합관계
#### UML 연관 관계의 특별 경우로 전체와 부분의 관계 를 명확하게 명시하고자할 때 사용한다.
<img width="473" alt="스크린샷 2021-05-27 오후 9 23 30" src="https://user-images.githubusercontent.com/60125719/119825351-d1420680-bf31-11eb-95ac-c8ded2c82757.png">

##### 집약 관계(aggregation)
- 한 객체가 다른 객체를 포함하는것
- '전체를 가리키는 클래스 방향에 빈 마름모로 표시
- 전체 객체의 라이프타임과 부분 객체의 라이프 타임은 독립적이다.
ex)
```
public class Computer {
    private MainBoard mb;
    private CPU c;
    // 생성자
    public Computer(MainBoard mb, CPU c) {
        this.bm = mb;
        this.c = c;
    }
}
```

##### 합성 관계(composition)
- 부분 객체가 전체 객체에 속하는 관계
- '전체' 를 가리키는 클래스 방향에 채워진 마름모로 표시
- 전체 객체의 라이프타임과 부분 객체의 라이프 타임은 의존적이다. -> 전체 객체가 없어지면 부분 객체도 없어진다.
ex)
```
public class Computer {
    private MainBoard mb;
    private CPU c;
    // 생성자
    public Computer() {
        this.mb = new MainBoard();
        this.c = new CPU();
    }
}
```

### 4. 의존 관계
#### 일반적으로 한 클래스가 다른 클래스를 사용하는 경우
 1. 클래스의 속성(“멤버 변수”)에서 참조할 때
 2. 연산의 “인자”(참조값)로 사용될 때
 3. 메서드 내부의 “지역 객체”로 참조될 때
 > 1번: 연관 관계 / 2,3번: 의존 관계
 
 <img width="452" alt="스크린샷 2021-05-27 오후 9 31 31" src="https://user-images.githubusercontent.com/60125719/119826558-1d417b00-bf33-11eb-9252-faaffa59ace4.png">
 

ex) 연관관계 - 오랜 시간동안 같이할 객체와의 관계
```
public class Person {
    // 클래스의 속성("맴버 변수")에서 참조
    private Car owns;
    // getter, setter
    public void setCar(Car car) {
        this.owns = car;
    }
    public Car getCar() {
        return this.owns;
    }
}
```

ex) 의존 관계 - 짧은 시간 동안 이용하는 관계, 점선
```
public class Car {
    ...
    // 연산의 "인자"(참조값)로 사용
    public void fillGas(GasPump p) {
        p.getGas(amount);
    }
}
```

### 5. 인터페이스와 실체화 관계
#### 인터페이스란
 - 책임이다.
 - 어떤 객체의 책임이란 객체가 해야 하는 일 또는 객체가 할 수 있는 일
 - 즉, 객체가 외부에 제공하는 서비스나 기능은 객체가 수행하는 책임으로 본다.
 - 어떤 공통되는 능력이 있는 것들을 대표하는 관점
#### UML에서의 인터페이스 표현
 - 인터페이스: 클래스에 사용하는 사각형을 그대로 사용하고 인터페이스 이름 위에 스테레오 타입으로 interface 표시(«interface»)
 - 인터페이스 관계: 빈 삼각형과 점선을 사용
 - 객체지향 개념에서는 실체화 관계를 “can do this” 관계 라고 한다.
 
 <img width="468" alt="스크린샷 2021-05-27 오후 9 35 04" src="https://user-images.githubusercontent.com/60125719/119826885-76111380-bf33-11eb-8a69-6b4b97da41b1.png">

 


