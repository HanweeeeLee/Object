> 이전 04장 항목 초반부가 중복되는 부분이 있음

## 04. 동적 메서드 탐색과 다형성
객체지향 시스템은 다음과 같은 규칙으로 실행할 메서드를 선택한다
 1. 먼저, 자신을 생성한 클래스에 적합한 메서드가 있는지 검사한다. 존재하면 메서드를 실행하고 탐색을 종료한다.
 2. 메서드를 찾이 못했다면, 부모 클래스에서 메서드 탐색을 계속한다. 적합한 메서드를 찾을 때까지 상속 계층을 따라 올라가며 계속된다.
 3. 상속 계층의 최상위 클래스에 이르렀지만 메서드를 발견하지 못한 경우 예외를 발생시키며 탐색을 중단한다.

### 04-1. 자동적인 메시지 위임
 - 상속을 이용할 경우 메시지를 처리할 방법을 알지 못할 경우 메시지에 대한 처리를 부모 클래스에 위임한다.
 - 적절한 메서드를 찾을 때까지 상속 계층을 따라 부모 클래스로 처리가 위임된다.
 - 상속을 이용할 경우 프로그래머가 메시지 위임과 관련된 코드를 명시적으로 작성할 필요가 없다. 메시지는 상속 계층을 따라 자동적으로 위임된다.
 - 자식 클래스 > 부모 클래스의 방향으로 메시지 처리가 위임되기 때문에 자식 클래스에서 어떤 메서드를 구현하고 있느냐에 따라 부모 클래스에 구현된 메서드의 운명이 결정된다.
 - 메서드 오버라이딩 : 자식 클래스의 메서드가 부모 클래스의 메서드를 감추게 된다.
```Java
Lecture lecture = new GradeLecture(...);
lecture.evalute();
```
![002](https://user-images.githubusercontent.com/50142323/132516639-3d24b916-1c28-43ab-9129-7bb6bbfd0132.png)
>Lecture.evaluate -> 는 GradeLecture.evaluate에 재정의 되어 있다.\
>실행시, self 참조에 의해 자기 자신의 클래스를 먼저 탐색하게 된다. 따라서, GradeLecture.evaluate()가 실행되게 되고, 오버라이딩된 부모 클래스의 메서드를 감추게 한다.
 - 메서드 오버로딩 : 자식 클래스의 메서드와 부모 클래스의 메서드가 공존한다.
```Java
Lecture lecture = new GradeLecture(...);
lecture.avaerage();
```
![003](https://user-images.githubusercontent.com/50142323/132517110-481faabb-9f87-47cb-9038-a5d8400723a2.png)
>오버라이딩과 마찬가지로 selft 참조를 하게 된다. GradeLecture에는 시그니처가 다르기에 부모 클래스에서 해당 시그니처를 찾게 된다.\
>이처럼 시그니처가 다르기 때문에 동일한 이름의 메서드가 공존하는 경우를 오버로딩이라 부른다.

### 04-2. 동적인 문맥
 - 메시지를 수신 했을 때 실제로 어떤 메서드를 실행 할지를 결정하는 것은 컴파일 시점이 아닌 실행 시점에 이뤄지며, 메서드를 탐색하는 경로는 self 참조를 이용해서 결정한다.
